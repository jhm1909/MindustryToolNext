[
  {
    "path": "wiki/getting-started",
    "content": "# Intro\n\nGetting started\n"
  },
  {
    "path": "wiki/logic/getting-started",
    "content": "---\nposition: 0\n---\n\n# Beginner's Guide\n\n## Introduction\n\nMindustry Logic (ML) is a built-in programming system that allows players to automate tasks using processors, memory cells, and linked structures. It functions like an assembly-style language, enabling automation of unit control, factory management, defense mechanisms, and resource distribution.\n\n## Basic Components\n\nMindustry Logic operates using several key components:\n\n- **Processors**: The core execution units that run logic scripts.\n- **Memory Cells**: Used to store and retrieve data persistently.\n- **Links**: Allow processors to interact with buildings, units, and resources.\n- **Variables**: Temporary data storage for calculations and control logic.\n\n## Flow of Execution\n\nMindustry Logic executes commands sequentially, line by line. It supports loops and conditional jumps to create complex behaviors. The general flow follows:\n\n1. **Reading Data**: Sensors retrieve information from linked buildings or units.\n2. **Processing Data**: Arithmetic operations and conditional checks determine the next steps.\n3. **Controlling Blocks/Units**: Commands are issued to blocks or units based on processed data.\n4. **Repeating or Ending Execution**: Execution loops until conditions are met or the script stops.\n\n## Basic Commands\n\nSome fundamental commands include:\n\n- `set var value` → Assigns a value to a variable.\n- `op operation result a b` → Performs arithmetic operations (`add`, `sub`, `mul`, `div`, etc.).\n- `print \"text\"` → Displays text in the processor’s console.\n- `end` → Terminates script execution.\n\n## Control Flow\n\nControl flow determines how a script proceeds based on conditions. Key commands:\n\n- `jump label` → Jumps to a predefined label.\n- `jump label condition a b` → Conditional jump if `a` and `b` satisfy the condition (`==`, `!=`, `<`, `>`, `<=`, `>=`).\n- `label myLabel` → Defines a point in the script for jumps.\n\n### Example: Basic Loop\n\n```js\nset counter 0\nlabel loop\n    print counter\n    op add counter counter 1\n    jump loop lessThan counter 10\n```\n\nThis loop prints numbers from 0 to 9 and stops when `counter` reaches 10.\n\n## Interacting with Blocks\n\nProcessors can interact with blocks using sensors and commands.\n\n- `sensor var block property` → Reads block data (e.g., `sensor power storage powerNetStored`).\n- `setblock x y type` → Places a block at the specified coordinates.\n- `getlink index var` → Retrieves a linked block.\n\n### Example: Checking Core Health\n\n```js\nsensor coreHealth core health\nprint coreHealth\njump loop\n```\n\nThis script prints the core’s health in a continuous loop.\n\n## Interacting with Units\n\nProcessors can control units to move, attack, and gather resources.\n\n- `ulocate mode x y var` → Finds the nearest unit in a specified mode (`enemy`, `ally`, `ore`).\n- `ucontrol command` → Issues a command to a unit (e.g., `move x y`, `mine x y`).\n\n### Example: Moving a Unit to (100, 200)\n\n```js\nucontrol move 100 200\n```\n\n## Practical Applications\n\nMindustry Logic is useful for various tasks, including:\n\n- **Factory Automation**: Automate supply chains by managing conveyor belts and factories.\n- **Turret Targeting**: Optimize turret control to prioritize specific enemies.\n- **Unit AI**: Command units for mining, defending, or attacking.\n- **Resource Monitoring**: Automatically check and redistribute resources.\n\nBy mastering Mindustry Logic, players can significantly enhance their base efficiency and defense automation. Start experimenting with processors today to build advanced logic-driven strategies!\n"
  },
  {
    "path": "wiki/logic/variables",
    "content": "---\nposition: 1\n---\n\n# Understanding Variables in Mindustry Logic\n\n## Basics of Variables\n\nVariables in Mindustry Logic are used to store and manipulate data during script execution. They allow for dynamic control of logic-based automation, such as tracking values, making calculations, and controlling flow.\n\n### Key Features:\n\n- Variables are stored in processor memory.\n- They can hold numbers, block states, or unit properties.\n- Values are updated dynamically as the script runs.\n- Variables can be used in conditional checks, loops, and arithmetic operations.\n\n## How to Use Variables\n\nYou can create and assign values to variables using the `set` command:\n\n```plaintext\nset myVar 10\n```\n\nThis assigns the value `10` to `myVar`.\n\nVariables can also store sensor data:\n\n```plaintext\nsensor coreHealth core health\n```\n\nThis stores the core’s health in the variable `coreHealth`.\n\n## Special Variables\n\nMindustry Logic has some special variables that hold important game data:\n\n- **`@counter`** → Stores the current loop iteration count. You can set it to jump to specific line\n- **`@tick`** → Stores the number of game ticks since the processor started.\n- **`@time`** → Stores the total time elapsed in the game in epoch.\n- **`@unit`** → Stores the currently controlled unit.\n- **`@this`** → Refers to the processor itself.\n- **`@mapw`** → Stores the width of the map.\n- **`@maph`** → Stores the height of the map.\n\n## Use Cases\n\nVariables are essential for:\n\n- **Tracking Resources**: Store values for power, items, or liquids.\n- **Unit Control**: Keep track of unit coordinates and states.\n- **Automation**: Store calculations for efficient production.\n- **Conditional Logic**: Compare values and execute actions accordingly.\n\n## Examples\n\n### Example 1: Counting Loops\n\n```plaintext\nset counter 0\nlabel loop\n    print counter\n    op add counter counter 1\n    jump loop lessThan counter 5\n```\n\nThis script prints numbers from 0 to 4 and stops.\n\n### Example 2: Checking Core Health\n\n```plaintext\nsensor health core health\nprint health\n```\n\nThis continuously monitors and prints the core’s health.\n\n### Example 3: Controlling Units\n\n```plaintext\nsensor x @unit x\nsensor y @unit y\nop add x x 10\nucontrol move x y\n```\n\nThis moves the unit 10 tiles to the right.\n\n---\n\nBy mastering variables, you can create powerful automation scripts to optimize your base and defenses!\n"
  },
  {
    "path": "wiki/logic/operations",
    "content": "---\nposition: 2\n---\n\n# Set, Operations, Lookup, and PackColor\n\nMindustry Logic (ML) is a powerful scripting system that allows for complex automation and control in the game. This guide covers fundamental ML commands, including `set`, various operations, `lookup`, and `packcolor`, with detailed explanations and examples.\n\n## Set\n\nThe `set` command assigns a value to a variable.\n\n### Syntax\n\n```plaintext\nset variable value\n```\n\n- `variable`: The name of the variable to store the value.\n- `value`: The value to assign.\n\n### Example\n\n```plaintext\nset myNumber 42\nprint myNumber  # Output: 42\n```\n\nThis is useful for storing constants, intermediates result, or flags in logic scripts.\n\n## Operations\n\nOperations in Mindustry Logic allow for mathematical and logical computations. These operations can be classified into several types:\n\n### Arithmetic Operations\n\n```plaintext\nop add result value1 value2  # Addition\nop sub result value1 value2  # Subtraction\nop mul result value1 value2  # Multiplication\nop div result value1 value2  # Division\nop mod result value1 value2  # Modulus (remainder)\n```\n\n**Example:**\n\n```plaintext\nop sum add 10 5\nprint sum  # Output: 15\n```\n\n### Comparison Operations\n\n```plaintext\nop equal result value1 value2   # Equals (==)\nop notEqual result value1 value2   # Not equals (!=)\nop lessThan result value1 value2   # Less than (<)\nop lessThanEq result value1 value2   # Less than or equal (<=)\nop greaterThan result value1 value2   # Greater than (>)\nop greaterThanEq result value1 value2   # Greater than or equal (>=)\n```\n\n**Example:**\n\n```plaintext\nop isGreater greaterThan 10 5\nprint isGreater  # Output: 1 (true)\n```\n\n### Bitwise Operations\n\n```plaintext\nop bitAnd result value1 value2  # Bitwise AND\nop bitOr result value1 value2  # Bitwise OR\nop bitXor result value1 value2  # Bitwise XOR\nop bitNot result value  # Bitwise NOT\n```\n\n**Example:**\n\n```plaintext\nop andResult bitAnd 6 3\nprint andResult  # Output: 2 (0110 & 0011 = 0010)\n```\n\n### Logical Operations\n\n```plaintext\nop land result value1 value2  # Logical AND\nop lor result value1 value2  # Logical OR\nop lnot result value  # Logical NOT\n```\n\n**Example:**\n\n```plaintext\nop logicResult land 1 0\nprint logicResult  # Output: 0 (false)\n```\n\n## Lookup\n\nThe `lookup` command retrieves information about an entity in the game. It can be used to inspect various properties of units, blocks, and items.\n\n### Syntax\n\n```plaintext\nlookup property result target\n```\n\n- `: result The variable to store the retrieved value.\n- `property`: The attribute to look up.\n- `target`: The entity or block to inspect.\n\n### Supported Properties\n\n- **General:** `id`, `type`\n- **Positioning:** `x`, `y`\n- **Health & Stats:** `health`, `maxHealth`\n- **Items & Ammo:** `ammo`, `itemCapacity`\n- **Units & Control:** `team`, `flag`, `dead`\n\n### Example\n\n```plaintext\nlookup unitHealth health @unit\nprint unitHealth  # Prints the health of the current unit\n```\n\n### Example for Block Lookup\n\n```plaintext\nlookup coreItems itemCapacity @core\nprint coreItems  # Prints the storage capacity of the core\n```\n\n## PackColor\n\nThe `packcolor` command encodes RGB(A) values into a single integer, useful for display and color manipulation.\n\n### Syntax\n\n```plaintext\npackcolor red result green blue alpha\n```\n\n- `: result The variable to store the packed color.\n- `red`, `green`, `blue`: RGB values (0–255).\n- `alpha`: Optional transparency (0–255).\n\n### Example\n\n```plaintext\npackcolor myColor 255 0 0 255  # Red color with full opacity\nprint myColor  # Outputs packed color value\n```\n\n### Example with Dynamic Color\n\n```plaintext\nset red 100\nset green 200\nset blue 50\npackcolor dynamicColor red green blue 255\nprint dynamicColor\n```\n\n## Conclusion\n\nUnderstanding `set`, operations, `lookup`, and `packcolor` enables efficient logic scripting in Mindustry. These commands allow you to manipulate data, interact with game entities, and create visually dynamic effects.\n"
  },
  {
    "path": "wiki/logic/flow-control",
    "content": "---\ntitle: 'Mindustry Logic - Control Flow Instructions'\ndescription: 'In-depth explanation of Mindustry Logic control flow instructions: end, stop, wait, and jump.'\nposition: 3\n---\n\n# Control Flow Instructions\n\nMindustry Logic provides various control flow instructions that allow scripts to manage execution flow efficiently. This page covers `end`, `stop`, `wait`, and `jump`, explaining their purpose and providing examples.\n\n## end\n\nThe `end` instruction immediately stops script execution. It is typically used to terminate the program explicitly.\n\n### Example:\n\n```plaintext\nprint \"Start\"\nend\nprint \"This will not be executed\"\n```\n\n**Explanation:** The script prints \"Start\", but after `end` is executed, all further instructions are ignored.\n\n## stop\n\nThe `stop` instruction halts execution but allows the script to restart in the next logic tick. It is useful for looping scripts that need periodic execution without consuming excessive processing power.\n\n### Example:\n\n```plaintext\nprint \"Running\"\nstop\nprint \"This will execute in the next tick\"\n```\n\n**Explanation:** The script prints \"Running\", then halts at `stop`. On the next logic tick, execution resumes at the next instruction.\n\n## wait\n\nThe `wait` instruction pauses execution for a specified number of logic ticks before continuing. This is useful for timing operations.\n\n### Syntax:\n\n```plaintext\nwait [ticks]\n```\n\n### Example:\n\n```plaintext\nprint \"Start\"\nwait 60\nprint \"This prints after 60 ticks\"\n```\n\n**Explanation:** The script prints \"Start\", then pauses for 60 logic ticks before executing the next instruction.\n\n## jump\n\nThe `jump` instruction moves execution to a specific line in the script based on a condition. It is useful for creating loops and conditional execution.\n\n### Syntax:\n\n```plaintext\njump [line] [condition]\n```\n\n### Example (Looping Counter):\n\n```plaintext\nset counter 0\n:loop\nprint counter\nop add counter counter 1\njump loop lessThan counter 5\n```\n\n**Explanation:** This script initializes `counter` to 0, prints it, increments it, and jumps back to the `loop` label until `counter` reaches 5.\n\n## Conclusion\n\n- Use `end` to terminate scripts immediately.\n- Use `stop` to pause execution until the next logic tick.\n- Use `wait` to introduce delays between instructions.\n- Use `jump` to control execution flow conditionally or create loops.\n\nBy mastering these instructions, you can write efficient Mindustry Logic scripts for automation and control systems.\n"
  },
  {
    "path": "wiki/logic/input-and-output",
    "content": "---\ntitle: 'Mindustry Logic - Input and Output Instructions'\ndescription: 'In-depth explanation of Mindustry Logic input and output instructions: read, write, draw, and print.'\nposition: 4\n---\n\n# Input and Output Instructions\n\nMindustry Logic provides various input and output instructions that allow scripts to read data, modify memory, draw graphics, and display text. This page covers `read`, `write`, `draw`, and `print`, explaining their purpose and providing examples.\n\n## read\n\nThe `read` instruction retrieves a value from a memory cell.\n\n### Syntax:\n\n```plaintext\nread [variable] [memoryCell] [index]\n```\n\n### Example:\n\n```plaintext\nread data memory1 0\nprint data\nprint flush\n```\n\n**Explanation:** This script reads the value stored at index `0` of `memory1` and prints it.\n\n## write\n\nThe `write` instruction stores a value in a memory cell at a specific index.\n\n### Syntax:\n\n```plaintext\nwrite [value] [memoryCell] [index]\n```\n\n### Example:\n\n```plaintext\nwrite 42 memory1 0\nread data memory1 0\nprint data\nprint flush\n```\n\n**Explanation:** This script stores `42` at index `0` in `memory1`, then reads and prints the value.\n\n## draw\n\nThe `draw` instruction is used to render shapes and text onto a display.\n\n### Syntax:\n\n```plaintext\ndraw [command] [param1] [param2] [param3] [param4]\ndraw flush\n```\n\n### Example (Drawing a Rectangle):\n\n```plaintext\ndraw color 255 0 0 255\ndraw rect 10 10 50 50\ndraw flush\n```\n\n**Explanation:** This script sets the draw color to red, draws a rectangle at (10,10) with a size of 50x50, and flushes the drawing commands to render them on the display.\n\n## print\n\nThe `print` instruction outputs text to the display or console.\n\n### Syntax:\n\n```plaintext\nprint [text]\nprint flush\n```\n\n### Example:\n\n```plaintext\nprint \"Hello, World!\"\nprint flush\n```\n\n**Explanation:** The script prints \"Hello, World!\" to the console or linked display.\n\n## Conclusion\n\n- Use `read` to retrieve data from memory cells.\n- Use `write` to store data in memory cells.\n- Use `draw` to create visual elements on a display.\n- Use `print` to output text information.\n\nBy mastering these instructions, you can create efficient Mindustry Logic scripts for automation and visualization.\n"
  },
  {
    "path": "wiki/logic/block-control",
    "content": "---\ntitle: 'Mindustry Logic - Block Control Instructions'\ndescription: 'In-depth explanation of Mindustry Logic block control instructions: draw flush, print flush, get link, sensor, control, and radar.'\nposition: 5\n---\n\n# Block Control Instructions\n\nMindustry Logic provides various block control instructions that allow scripts to interact with the game world efficiently. This page covers `draw flush`, `print flush`, `get link`, `sensor`, `control`, and `radar`, explaining their purpose and providing examples.\n\n## draw flush\n\nThe `draw flush` instruction commits all previously issued draw operations to the screen. Without this, drawing commands will not be rendered until the script stops or reaches a flush point.\n\n### Example:\n\n```plaintext\ndraw color 255 0 0 255\ndraw rect 10 10 50 50\ndraw flush\n```\n\n**Explanation:** This script sets the draw color to red, draws a rectangle at (10,10) with a size of 50x50, and then flushes the drawing commands to render them on the display.\n\n## print flush\n\nThe `print flush` instruction commits all `print` commands to the message display or linked terminal block.\n\n### Example:\n\n```plaintext\nprint \"Hello, World!\"\nprint flush\n```\n\n**Explanation:** The script queues \"Hello, World!\" and then flushes it, ensuring it is displayed on the linked display or message block.\n\n## get link\n\nThe `get link` instruction assigns a linked block to a variable for interaction.\n\n### Syntax:\n\n```plaintext\nget link [variable] [index]\n```\n\n### Example:\n\n```plaintext\nget link core 1\nprint core\n```\n\n**Explanation:** The script links the block at index 1 to the variable `core` and prints its reference.\n\n## sensor\n\nThe `sensor` instruction retrieves data from a block or unit.\n\n### Syntax:\n\n```plaintext\nsensor [variable] [target] [property]\n```\n\n### Example:\n\n```plaintext\nsensor health core1 @health\nprint health\nprint flush\n```\n\n**Explanation:** The script retrieves the `health` of the block stored in `core1` and prints the value.\n\n## control\n\nThe `control` instruction sends commands to blocks such as turrets or units.\n\n### Syntax:\n\n```plaintext\ncontrol [block] [command] [param1] [param2] [param3]\n```\n\n### Example:\n\n```plaintext\ncontrol turret shoot 100 100 1\n```\n\n**Explanation:** The script commands a turret to shoot at coordinates (100,100) with a shooting power of 1.\n\n## radar\n\nThe `radar` instruction scans for enemy units based on given parameters.\n\n### Syntax:\n\n```plaintext\nradar [sort] [target] [filter] [outputVariable]\n```\n\n### Example:\n\n```plaintext\nradar closest enemy any target\nprint target\nprint flush\n```\n\n**Explanation:** The script scans for the closest enemy unit and stores the result in `target`, which is then printed.\n\n## Conclusion\n\n- Use `draw flush` to finalize drawing commands.\n- Use `print flush` to finalize print operations.\n- Use `get link` to interact with specific blocks.\n- Use `sensor` to retrieve block or unit data.\n- Use `control` to send commands to units or turrets.\n- Use `radar` to detect enemy units.\n\nBy mastering these instructions, you can create efficient automation scripts in Mindustry Logic.\n"
  },
  {
    "path": "wiki/logic/unit-control",
    "content": "---\ntitle: 'Mindustry Logic - Unit Control Instructions'\ndescription: 'In-depth explanation of Mindustry Logic unit control instructions: unit bind, unit control, unit radar, and unit locate.'\nposition: 6\n---\n\n# Unit Control Instructions\n\nMindustry Logic provides various unit control instructions that allow scripts to command and manage units efficiently. This page covers `unit bind`, `unit control`, `unit radar`, and `unit locate`, explaining their purpose and providing examples.\n\n## unit bind\n\nThe `unit bind` instruction binds a unit to the script, allowing control over it.\n\n### Syntax:\n\n```plaintext\nunit bind [unit]\n```\n\n### Example:\n\n```plaintext\nunit bind @flare\nprint \"Unit bound!\"\nprint flush\n```\n\n**Explanation:** This script binds a `flare` unit to the script, allowing it to be controlled.\n\n## unit control\n\nThe `unit control` instruction issues commands to the bound unit, such as moving, attacking, or boosting.\n\n### Syntax:\n\n```plaintext\nunit control [command] [param1] [param2] [param3] [param4]\n```\n\n### Example (Move to Position):\n\n```plaintext\nunit control move 100 100 0 0\n```\n\n**Explanation:** The script commands the bound unit to move to coordinates (100,100).\n\n### Example (Attack Enemy):\n\n```plaintext\nunit control attack 200 200 1 0\n```\n\n**Explanation:** The script commands the unit to attack at coordinates (200,200) with priority enabled.\n\n## unit radar\n\nThe `unit radar` instruction scans for units based on criteria such as team and distance.\n\n### Syntax:\n\n```plaintext\nunit radar [sort] [team] [type] [outputVariable]\n```\n\n### Example:\n\n```plaintext\nunit radar closest enemy any target\nprint target\nprint flush\n```\n\n**Explanation:** The script scans for the closest enemy unit and stores the result in `target`, which is then printed.\n\n## unit locate\n\nThe `unit locate` instruction finds the closest core, spawn, or enemy.\n\n### Syntax:\n\n```plaintext\nunit locate [target] [outputX] [outputY] [foundVariable]\n```\n\n### Example (Locate Nearest Core):\n\n```plaintext\nunit locate core coreX coreY found\nprint coreX\nprint coreY\nprint found\nprint flush\n```\n\n**Explanation:** The script finds the nearest core, storing its coordinates in `coreX` and `coreY`. The `found` variable indicates if a core was located.\n\n## Conclusion\n\n- Use `unit bind` to bind a unit for control.\n- Use `unit control` to issue commands to the bound unit.\n- Use `unit radar` to detect nearby units based on criteria.\n- Use `unit locate` to find strategic locations such as cores and enemies.\n\nBy mastering these instructions, you can create efficient unit automation scripts in Mindustry Logic.\n"
  },
  {
    "path": "api/getting-started",
    "content": "# Getting started\n\nDocument for using mindustry-tool Api\n"
  },
  {
    "path": "wiki/logic/getting-started",
    "content": "# Mindustry Logic: Hướng Dẫn Cơ Bản\n\n## Giới Thiệu\n\nMindustry Logic (ML) là một hệ thống lập trình tích hợp cho phép người chơi tự động hóa các nhiệm vụ bằng cách sử dụng bộ xử lý, ô nhớ và các liên kết. Nó hoạt động như một ngôn ngữ kiểu assembly, giúp tự động hóa việc điều khiển đơn vị, quản lý nhà máy, hệ thống phòng thủ và phân phối tài nguyên.\n\n## Thành Phần Cơ Bản\n\nMindustry Logic hoạt động dựa trên các thành phần chính sau:\n\n- **Bộ xử lý (Processors)**: Đơn vị thực thi chạy các tập lệnh logic.\n- **Ô nhớ (Memory Cells)**: Dùng để lưu trữ và truy xuất dữ liệu lâu dài.\n- **Liên kết (Links)**: Cho phép bộ xử lý tương tác với công trình, đơn vị và tài nguyên.\n- **Biến (Variables)**: Lưu trữ dữ liệu tạm thời để tính toán và điều khiển logic.\n\n## Luồng Thực Thi\n\nMindustry Logic thực thi các lệnh tuần tự, từng dòng một. Nó hỗ trợ vòng lặp và điều kiện nhảy để tạo ra các hành vi phức tạp. Luồng thực thi chung như sau:\n\n1. **Đọc dữ liệu**: Cảm biến lấy thông tin từ các công trình hoặc đơn vị được liên kết.\n2. **Xử lý dữ liệu**: Các phép toán số học và điều kiện kiểm tra quyết định bước tiếp theo.\n3. **Điều khiển khối/đơn vị**: Lệnh được gửi đến khối hoặc đơn vị dựa trên dữ liệu đã xử lý.\n4. **Lặp lại hoặc kết thúc thực thi**: Tiến trình lặp lại cho đến khi điều kiện được đáp ứng hoặc tập lệnh dừng lại.\n\n## Lệnh Cơ Bản\n\nMột số lệnh quan trọng bao gồm:\n\n- `set var value` → Gán giá trị cho một biến.\n- `op operation result a b` → Thực hiện các phép toán số học (`add`, `sub`, `mul`, `div`, v.v.).\n- `print \"text\"` → Hiển thị văn bản trên bảng điều khiển của bộ xử lý.\n- `end` → Kết thúc thực thi tập lệnh.\n\n## Điều Khiển Luồng\n\nĐiều khiển luồng xác định cách tập lệnh tiếp tục dựa trên điều kiện. Các lệnh quan trọng:\n\n- `jump label` → Nhảy đến một nhãn được định nghĩa trước.\n- `jump label condition a b` → Nhảy có điều kiện nếu `a` và `b` thỏa mãn điều kiện (`==`, `!=`, `<`, `>`, `<=`, `>=`).\n- `label myLabel` → Định nghĩa một điểm trong tập lệnh để nhảy đến.\n\n### Ví Dụ: Vòng Lặp Cơ Bản\n\n```py\nset counter 0\nlabel loop\n    print counter\n    op add counter counter 1\n    jump loop lessThan counter 10\n```\n\nVòng lặp này in ra các số từ 0 đến 9 và dừng lại khi `counter` đạt 10.\n\n## Tương Tác Với Công Trình\n\nBộ xử lý có thể tương tác với công trình bằng cảm biến và lệnh.\n\n- `sensor var block property` → Đọc dữ liệu từ công trình (ví dụ: `sensor power storage powerNetStored`).\n- `setblock x y type` → Đặt một khối tại tọa độ chỉ định.\n- `getlink index var` → Lấy công trình đã liên kết.\n\n### Ví Dụ: Kiểm Tra Máu Lõi\n\n```py\nsensor coreHealth core health\nprint coreHealth\njump loop\n```\n\nTập lệnh này in ra máu của lõi trong một vòng lặp liên tục.\n\n## Tương Tác Với Đơn Vị\n\nBộ xử lý có thể điều khiển đơn vị di chuyển, tấn công và khai thác tài nguyên.\n\n- `ulocate mode x y var` → Tìm đơn vị gần nhất trong chế độ được chỉ định (`enemy`, `ally`, `ore`).\n- `ucontrol command` → Ra lệnh cho đơn vị (ví dụ: `move x y`, `mine x y`).\n\n### Ví Dụ: Di Chuyển Một Đơn Vị Đến (100, 200)\n\n```py\nucontrol move 100 200\n```\n\n## Ứng Dụng Thực Tiễn\n\nMindustry Logic rất hữu ích cho nhiều nhiệm vụ, bao gồm:\n\n- **Tự động hóa nhà máy**: Quản lý chuỗi cung ứng bằng cách điều khiển băng tải và nhà máy.\n- **Điều khiển tháp pháo**: Tối ưu hóa hệ thống phòng thủ để ưu tiên mục tiêu cụ thể.\n- **AI cho đơn vị**: Ra lệnh cho đơn vị khai thác, phòng thủ hoặc tấn công.\n- **Giám sát tài nguyên**: Kiểm tra và phân phối tài nguyên một cách tự động.\n\nBằng cách làm chủ Mindustry Logic, người chơi có thể nâng cao đáng kể hiệu quả của căn cứ và tự động hóa hệ thống phòng thủ. Hãy bắt đầu thử nghiệm với bộ xử lý ngay hôm nay để xây dựng các chiến lược dựa trên logic tiên tiến!\n"
  },
  {
    "path": "wiki/logic/variables",
    "content": "---\nposition: 1\n---\n\n# Hiểu về Biến trong Mindustry Logic\n\n## Tổng Quan về Biến\n\nBiến trong Mindustry Logic được sử dụng để lưu trữ và thao tác dữ liệu trong quá trình thực thi kịch bản. Chúng giúp kiểm soát động các hệ thống tự động hóa bằng logic, như theo dõi giá trị, thực hiện tính toán và kiểm soát luồng chương trình.\n\n### Đặc Điểm Chính:\n\n- Biến được lưu trong bộ nhớ của bộ xử lý (processor).\n- Chúng có thể chứa số, trạng thái khối hoặc thuộc tính của đơn vị.\n- Giá trị được cập nhật động trong quá trình chạy kịch bản.\n- Biến có thể được sử dụng trong các điều kiện, vòng lặp và phép toán.\n\n## Cách Sử Dụng Biến\n\nBạn có thể tạo và gán giá trị cho biến bằng lệnh `set`:\n\n```plaintext\nset myVar 10\n```\n\nLệnh này gán giá trị `10` cho `myVar`.\n\nBiến cũng có thể lưu trữ dữ liệu cảm biến:\n\n```plaintext\nsensor coreHealth core health\n```\n\nLệnh này lưu trữ máu của lõi (`core`) vào biến `coreHealth`.\n\n## Biến Đặc Biệt\n\nMindustry Logic có một số biến đặc biệt chứa dữ liệu quan trọng trong trò chơi:\n\n- **`@counter`** → Lưu số lần lặp hiện tại, có thể đặt để nhảy đến dòng cụ thể.\n- **`@tick`** → Lưu số tick đã trôi qua kể từ khi bộ xử lý bắt đầu.\n- **`@time`** → Lưu tổng thời gian đã trôi qua trong game theo epoch.\n- **`@unit`** → Lưu đơn vị hiện đang được điều khiển.\n- **`@this`** → Tham chiếu đến bộ xử lý hiện tại.\n- **`@mapw`** → Lưu chiều rộng của bản đồ.\n- **`@maph`** → Lưu chiều cao của bản đồ.\n\n## Ứng Dụng\n\nBiến rất quan trọng trong:\n\n- **Theo dõi tài nguyên**: Lưu giá trị về điện, vật phẩm hoặc chất lỏng.\n- **Điều khiển đơn vị**: Lưu tọa độ và trạng thái của đơn vị.\n- **Tự động hóa**: Lưu kết quả tính toán để tối ưu hóa sản xuất.\n- **Điều kiện logic**: So sánh giá trị và thực thi hành động phù hợp.\n\n## Ví Dụ\n\n### Ví dụ 1: Đếm Vòng Lặp\n\n```plaintext\nset counter 0\nlabel loop\n    print counter\n    op add counter counter 1\n    jump loop lessThan counter 5\n```\n\nKịch bản này in ra các số từ 0 đến 4 rồi dừng.\n\n### Ví dụ 2: Kiểm Tra Máu Của Lõi\n\n```plaintext\nsensor health core health\nprint health\n```\n\nKịch bản này liên tục theo dõi và in ra lượng máu của lõi.\n\n### Ví dụ 3: Điều Khiển Đơn Vị\n\n```plaintext\nsensor x @unit x\nsensor y @unit y\nop add x x 10\nucontrol move x y\n```\n\nKịch bản này di chuyển đơn vị sang phải 10 ô.\n\n---\n\nNắm vững cách sử dụng biến sẽ giúp bạn tạo ra các kịch bản tự động hóa mạnh mẽ để tối ưu hóa căn cứ và hệ thống phòng thủ của mình!\n"
  },
  {
    "path": "wiki/logic/operations",
    "content": "---\nposition: 2\n---\n\n# Set, Op, Lookup, và PackColor\n\nMindustry Logic (ML) là một hệ thống lập trình mạnh mẽ cho phép tự động hóa và điều khiển phức tạp trong trò chơi. Hướng dẫn này sẽ trình bày chi tiết các lệnh cơ bản trong ML, bao gồm `set`, các toán tử, `lookup`, và `packcolor`, kèm theo ví dụ minh họa.\n\n## Set\n\nLệnh `set` dùng để gán giá trị cho một biến.\n\n### Cú pháp\n\n```plaintext\nset biến giá_trị\n```\n\n- `biến`: Tên biến sẽ lưu giá trị.\n- `giá_trị`: Giá trị cần gán.\n\n### Ví dụ\n\n```plaintext\nset myNumber 42\nprint myNumber  # Kết quả: 42\n```\n\nLệnh này hữu ích để lưu trữ hằng số, kết quả trung gian hoặc cờ trạng thái trong script logic.\n\n## Toán Tử\n\nToán tử trong Mindustry Logic cho phép thực hiện các phép toán số học và logic. Chúng được phân thành nhiều loại khác nhau:\n\n### Toán Tử Số Học\n\n```plaintext\nop add kết_quả giá_trị1 giá_trị2  # Cộng\nop sub kết_quả giá_trị1 giá_trị2  # Trừ\nop mul kết_quả giá_trị1 giá_trị2  # Nhân\nop div kết_quả giá_trị1 giá_trị2  # Chia\nop mod kết_quả giá_trị1 giá_trị2  # Chia lấy dư\n```\n\n**Ví dụ:**\n\n```plaintext\nop sum add 10 5\nprint sum  # Kết quả: 15\n```\n\n### Toán Tử So Sánh\n\n```plaintext\nop equal kết_quả giá_trị1 giá_trị2   # Bằng (==)\nop notEqual kết_quả giá_trị1 giá_trị2   # Khác (!=)\nop lessThan kết_quả giá_trị1 giá_trị2   # Nhỏ hơn (<)\nop lessThanEq kết_quả giá_trị1 giá_trị2   # Nhỏ hơn hoặc bằng (<=)\nop greaterThan kết_quả giá_trị1 giá_trị2   # Lớn hơn (>)\nop greaterThanEq kết_quả giá_trị1 giá_trị2   # Lớn hơn hoặc bằng (>=)\n```\n\n**Ví dụ:**\n\n```plaintext\nop isGreater greaterThan 10 5\nprint isGreater  # Kết quả: 1 (true)\n```\n\n### Toán Tử Bitwise\n\n```plaintext\nop bitAnd kết_quả giá_trị1 giá_trị2  # AND bit\nop bitOr kết_quả giá_trị1 giá_trị2  # OR bit\nop bitXor kết_quả giá_trị1 giá_trị2  # XOR bit\nop bitNot kết_quả giá_trị  # NOT bit\n```\n\n**Ví dụ:**\n\n```plaintext\nop andResult bitAnd 6 3\nprint andResult  # Kết quả: 2 (0110 & 0011 = 0010)\n```\n\n### Toán Tử Logic\n\n```plaintext\nop land kết_quả giá_trị1 giá_trị2  # AND logic\nop lor kết_quả giá_trị1 giá_trị2  # OR logic\nop lnot kết_quả giá_trị  # NOT logic\n```\n\n**Ví dụ:**\n\n```plaintext\nop logicResult land 1 0\nprint logicResult  # Kết quả: 0 (false)\n```\n\n## Lookup\n\nLệnh `lookup` dùng để lấy thông tin về một thực thể trong trò chơi. Nó có thể được sử dụng để kiểm tra các thuộc tính của đơn vị, khối, và vật phẩm.\n\n### Cú pháp\n\n```plaintext\nlookup thuộc_tính kết_quả mục_tiêu\n```\n\n- `kết_quả`: Biến dùng để lưu giá trị lấy được.\n- `thuộc_tính`: Thuộc tính cần truy vấn.\n- `mục_tiêu`: Đối tượng hoặc khối cần kiểm tra.\n\n### Các Thuộc Tính Hỗ Trợ\n\n- **Chung:** `id`, `type`\n- **Vị trí:** `x`, `y`\n- **Chỉ số sinh tồn:** `health`, `maxHealth`\n- **Vật phẩm & Đạn dược:** `ammo`, `itemCapacity`\n- **Đơn vị & Điều khiển:** `team`, `flag`, `dead`\n\n### Ví dụ\n\n```plaintext\nlookup unitHealth health @unit\nprint unitHealth  # In ra máu của đơn vị hiện tại\n```\n\n### Ví dụ Kiểm Tra Khối\n\n```plaintext\nlookup coreItems itemCapacity @core\nprint coreItems  # In ra sức chứa vật phẩm của lõi\n```\n\n## PackColor\n\nLệnh `packcolor` dùng để mã hóa giá trị RGB(A) thành một số nguyên duy nhất, hữu ích để hiển thị màu sắc trong trò chơi.\n\n### Cú pháp\n\n```plaintext\npackcolor đỏ kết_quả xanh_lá xanh_dương alpha\n```\n\n- `kết_quả`: Biến dùng để lưu giá trị màu.\n- `đỏ`, `xanh_lá`, `xanh_dương`: Giá trị RGB (0–255).\n- `alpha`: Độ trong suốt (0–255, tùy chọn).\n\n### Ví dụ\n\n```plaintext\npackcolor myColor 255 0 0 255  # Màu đỏ với độ trong suốt tối đa\nprint myColor  # Xuất giá trị màu đã đóng gói\n```\n\n### Ví dụ với Màu Động\n\n```plaintext\nset red 100\nset green 200\nset blue 50\npackcolor dynamicColor red green blue 255\nprint dynamicColor\n```\n\n## Kết Luận\n\nHiểu rõ cách sử dụng `set`, các toán tử, `lookup`, và `packcolor` sẽ giúp bạn lập trình logic hiệu quả trong Mindustry. Những lệnh này cho phép bạn thao tác dữ liệu, tương tác với thực thể trong trò chơi và tạo hiệu ứng màu sắc trực quan.\n"
  },
  {
    "path": "wiki/logic/flow-control",
    "content": "---\ntitle: 'Mindustry Logic - Hướng Dẫn Điều Khiển Luồng'\ndescription: 'Giải thích chi tiết về các lệnh điều khiển luồng trong Mindustry Logic: end, stop, wait, và jump.'\nposition: 3\n---\n\n# Hướng Dẫn Điều Khiển Luồng\n\nMindustry Logic cung cấp nhiều lệnh điều khiển luồng giúp quản lý quá trình thực thi của script một cách hiệu quả. Trang này sẽ giải thích chi tiết về `end`, `stop`, `wait`, và `jump`, kèm theo ví dụ minh họa.\n\n## end\n\nLệnh `end` dừng ngay lập tức quá trình thực thi của script. Thường được sử dụng để kết thúc chương trình một cách rõ ràng.\n\n### Ví dụ:\n\n```plaintext\nprint \"Bắt đầu\"\nend\nprint \"Dòng này sẽ không được thực thi\"\n```\n\n**Giải thích:** Script in ra `\"Bắt đầu\"`, nhưng sau khi `end` được thực thi, tất cả các lệnh tiếp theo sẽ bị bỏ qua.\n\n## stop\n\nLệnh `stop` tạm dừng thực thi nhưng cho phép script khởi động lại ở tick logic tiếp theo. Nó hữu ích cho các script lặp lại mà không tiêu tốn quá nhiều tài nguyên xử lý.\n\n### Ví dụ:\n\n```plaintext\nprint \"Đang chạy\"\nstop\nprint \"Dòng này sẽ được thực thi ở tick tiếp theo\"\n```\n\n**Giải thích:** Script in ra `\"Đang chạy\"`, sau đó dừng tại `stop`. Ở tick logic tiếp theo, quá trình thực thi tiếp tục với lệnh tiếp theo.\n\n## wait\n\nLệnh `wait` tạm dừng thực thi trong một số tick logic nhất định trước khi tiếp tục. Dùng để tạo độ trễ giữa các thao tác.\n\n### Cú pháp:\n\n```plaintext\nwait [số tick]\n```\n\n### Ví dụ:\n\n```plaintext\nprint \"Bắt đầu\"\nwait 60\nprint \"Dòng này in ra sau 60 tick\"\n```\n\n**Giải thích:** Script in ra `\"Bắt đầu\"`, sau đó tạm dừng 60 tick logic trước khi thực thi lệnh tiếp theo.\n\n## jump\n\nLệnh `jump` chuyển quá trình thực thi đến một dòng cụ thể trong script dựa trên điều kiện. Hữu ích để tạo vòng lặp và điều kiện rẽ nhánh.\n\n### Cú pháp:\n\n```plaintext\njump [dòng] [điều kiện]\n```\n\n### Ví dụ (Vòng lặp đếm):\n\n```plaintext\nset counter 0\n:loop\nprint counter\nop add counter counter 1\njump loop lessThan counter 5\n```\n\n**Giải thích:** Script này khởi tạo `counter` bằng 0, in ra giá trị, tăng nó lên 1, và quay lại nhãn `loop` cho đến khi `counter` đạt 5.\n\n## Kết luận\n\n- Dùng `end` để kết thúc script ngay lập tức.\n- Dùng `stop` để tạm dừng thực thi cho đến tick logic tiếp theo.\n- Dùng `wait` để tạo độ trễ giữa các lệnh.\n- Dùng `jump` để kiểm soát luồng thực thi theo điều kiện hoặc tạo vòng lặp.\n\nNắm vững các lệnh này sẽ giúp bạn viết script Mindustry Logic hiệu quả cho các hệ thống tự động hóa và điều khiển.\n"
  },
  {
    "path": "wiki/logic/input-and-output",
    "content": "---\ntitle: 'Mindustry Logic - Hướng Dẫn Nhập Xuất Dữ Liệu'\ndescription: 'Giải thích chi tiết về các lệnh nhập xuất trong Mindustry Logic: read, write, draw, và print.'\nposition: 4\n---\n\n# Hướng Dẫn Nhập Xuất Dữ Liệu\n\nMindustry Logic cung cấp nhiều lệnh nhập xuất giúp script có thể đọc dữ liệu, sửa đổi bộ nhớ, vẽ đồ họa và hiển thị văn bản. Trang này sẽ giải thích chi tiết về `read`, `write`, `draw`, và `print`, kèm theo ví dụ minh họa.\n\n## read\n\nLệnh `read` dùng để lấy giá trị từ một ô nhớ.\n\n### Cú pháp:\n\n```plaintext\nread [biến] [ô nhớ] [chỉ mục]\n```\n\n### Ví dụ:\n\n```plaintext\nread data memory1 0\nprint data\nprint flush\n```\n\n**Giải thích:** Script này đọc giá trị tại chỉ mục `0` của `memory1` và in ra màn hình.\n\n## write\n\nLệnh `write` dùng để lưu giá trị vào một ô nhớ tại một chỉ mục nhất định.\n\n### Cú pháp:\n\n```plaintext\nwrite [giá trị] [ô nhớ] [chỉ mục]\n```\n\n### Ví dụ:\n\n```plaintext\nwrite 42 memory1 0\nread data memory1 0\nprint data\nprint flush\n```\n\n**Giải thích:** Script này lưu giá trị `42` vào chỉ mục `0` của `memory1`, sau đó đọc và in ra giá trị đó.\n\n## draw\n\nLệnh `draw` dùng để vẽ hình và hiển thị văn bản trên màn hình.\n\n### Cú pháp:\n\n```plaintext\ndraw [lệnh] [tham số1] [tham số2] [tham số3] [tham số4]\ndraw flush\n```\n\n### Ví dụ (Vẽ hình chữ nhật):\n\n```plaintext\ndraw color 255 0 0 255\ndraw rect 10 10 50 50\ndraw flush\n```\n\n**Giải thích:** Script này đặt màu vẽ thành đỏ, vẽ một hình chữ nhật tại (10,10) với kích thước 50x50, sau đó thực thi `draw flush` để hiển thị hình vẽ.\n\n## print\n\nLệnh `print` dùng để hiển thị văn bản trên màn hình hoặc bảng điều khiển.\n\n### Cú pháp:\n\n```plaintext\nprint [văn bản]\nprint flush\n```\n\n### Ví dụ:\n\n```plaintext\nprint \"Xin chào, Thế giới!\"\nprint flush\n```\n\n**Giải thích:** Script này in `\"Xin chào, Thế giới!\"` ra màn hình hoặc bảng điều khiển.\n\n## Kết luận\n\n- Dùng `read` để lấy dữ liệu từ ô nhớ.\n- Dùng `write` để lưu dữ liệu vào ô nhớ.\n- Dùng `draw` để tạo các phần tử đồ họa trên màn hình.\n- Dùng `print` để hiển thị văn bản.\n\nNắm vững các lệnh này sẽ giúp bạn viết script Mindustry Logic hiệu quả cho các hệ thống tự động hóa và trực quan hóa.\n"
  },
  {
    "path": "wiki/logic/block-control",
    "content": "---\ntitle: 'Mindustry Logic - Hướng Dẫn Điều Khiển Khối'\ndescription: 'Giải thích chi tiết về các lệnh điều khiển khối trong Mindustry Logic: draw flush, print flush, get link, sensor, control, và radar.'\nposition: 5\n---\n\n# Hướng Dẫn Điều Khiển Khối\n\nMindustry Logic cung cấp nhiều lệnh điều khiển khối giúp script tương tác hiệu quả với thế giới trong game. Trang này sẽ giải thích chi tiết về `draw flush`, `print flush`, `get link`, `sensor`, `control`, và `radar`, kèm theo ví dụ minh họa.\n\n## draw flush\n\nLệnh `draw flush` xác nhận tất cả các thao tác vẽ trước đó lên màn hình. Nếu không có lệnh này, các lệnh vẽ sẽ không được hiển thị cho đến khi script dừng hoặc đến điểm flush.\n\n### Ví dụ:\n\n```plaintext\ndraw color 255 0 0 255\ndraw rect 10 10 50 50\ndraw flush\n```\n\n**Giải thích:** Script này đặt màu vẽ thành đỏ, vẽ một hình chữ nhật tại tọa độ (10,10) với kích thước 50x50, sau đó flush để hiển thị lên màn hình.\n\n## print flush\n\nLệnh `print flush` xác nhận tất cả các lệnh `print` để hiển thị trên màn hình tin nhắn hoặc khối terminal được liên kết.\n\n### Ví dụ:\n\n```plaintext\nprint \"Hello, World!\"\nprint flush\n```\n\n**Giải thích:** Script này xếp hàng hiển thị chuỗi `\"Hello, World!\"` và flush để đảm bảo nó xuất hiện trên màn hình hoặc khối tin nhắn.\n\n## get link\n\nLệnh `get link` liên kết một khối cụ thể vào một biến để có thể tương tác với nó.\n\n### Cú pháp:\n\n```plaintext\nget link [biến] [chỉ mục]\n```\n\n### Ví dụ:\n\n```plaintext\nget link core 1\nprint core\n```\n\n**Giải thích:** Script này liên kết khối có chỉ mục 1 vào biến `core` và in ra thông tin về nó.\n\n## sensor\n\nLệnh `sensor` lấy dữ liệu từ một khối hoặc đơn vị.\n\n### Cú pháp:\n\n```plaintext\nsensor [biến] [mục tiêu] [thuộc tính]\n```\n\n### Ví dụ:\n\n```plaintext\nsensor health core1 @health\nprint health\nprint flush\n```\n\n**Giải thích:** Script này lấy giá trị `health` (máu) của khối được lưu trong `core1` và in ra.\n\n## control\n\nLệnh `control` gửi lệnh điều khiển đến các khối như tháp pháo hoặc đơn vị.\n\n### Cú pháp:\n\n```plaintext\ncontrol [khối] [lệnh] [tham số 1] [tham số 2] [tham số 3]\n```\n\n### Ví dụ:\n\n```plaintext\ncontrol turret shoot 100 100 1\n```\n\n**Giải thích:** Script này ra lệnh cho tháp pháo bắn vào tọa độ (100,100) với sức mạnh bắn là 1.\n\n## radar\n\nLệnh `radar` quét tìm đơn vị địch dựa trên các tiêu chí nhất định.\n\n### Cú pháp:\n\n```plaintext\nradar [sắp xếp] [mục tiêu] [bộ lọc] [biến đầu ra]\n```\n\n### Ví dụ:\n\n```plaintext\nradar closest enemy any target\nprint target\nprint flush\n```\n\n**Giải thích:** Script này quét tìm đơn vị địch gần nhất, lưu kết quả vào `target`, rồi in ra.\n\n## Kết luận\n\n- Dùng `draw flush` để xác nhận các lệnh vẽ.\n- Dùng `print flush` để hiển thị nội dung in ra.\n- Dùng `get link` để tương tác với các khối cụ thể.\n- Dùng `sensor` để lấy dữ liệu từ khối hoặc đơn vị.\n- Dùng `control` để gửi lệnh đến đơn vị hoặc tháp pháo.\n- Dùng `radar` để quét tìm đơn vị địch.\n\nNắm vững các lệnh này sẽ giúp bạn tạo script tự động hóa hiệu quả trong Mindustry Logic.\n"
  },
  {
    "path": "wiki/logic/unit-control",
    "content": "---\ntitle: 'Mindustry Logic - Hướng Dẫn Điều Khiển Đơn Vị'\ndescription: 'Giải thích chi tiết về các lệnh điều khiển đơn vị trong Mindustry Logic: unit bind, unit control, unit radar, và unit locate.'\nposition: 6\n---\n\n# Hướng Dẫn Điều Khiển Đơn Vị\n\nMindustry Logic cung cấp nhiều lệnh điều khiển đơn vị giúp kịch bản có thể ra lệnh và quản lý đơn vị hiệu quả. Trang này sẽ hướng dẫn về `unit bind`, `unit control`, `unit radar`, và `unit locate`, kèm theo giải thích và ví dụ minh họa.\n\n## unit bind\n\nLệnh `unit bind` gán một đơn vị vào kịch bản, cho phép nó được điều khiển.\n\n### Cú pháp:\n\n```plaintext\nunit bind [đơn_vị]\n```\n\n### Ví dụ:\n\n```plaintext\nunit bind @flare\nprint \"Đơn vị đã được gán!\"\nprint flush\n```\n\n**Giải thích:** Kịch bản này gán một đơn vị `flare` vào kịch bản, cho phép nó được điều khiển.\n\n## unit control\n\nLệnh `unit control` ra lệnh cho đơn vị đã được gán, bao gồm di chuyển, tấn công hoặc tăng tốc.\n\n### Cú pháp:\n\n```plaintext\nunit control [lệnh] [tham_số1] [tham_số2] [tham_số3] [tham_số4]\n```\n\n### Ví dụ (Di chuyển đến vị trí):\n\n```plaintext\nunit control move 100 100 0 0\n```\n\n**Giải thích:** Kịch bản ra lệnh cho đơn vị đã gán di chuyển đến tọa độ (100,100).\n\n### Ví dụ (Tấn công kẻ địch):\n\n```plaintext\nunit control attack 200 200 1 0\n```\n\n**Giải thích:** Kịch bản ra lệnh cho đơn vị tấn công tại tọa độ (200,200) với ưu tiên bật.\n\n## unit radar\n\nLệnh `unit radar` quét tìm đơn vị dựa trên tiêu chí như đội và khoảng cách.\n\n### Cú pháp:\n\n```plaintext\nunit radar [sắp_xếp] [đội] [loại] [biến_kết_quả]\n```\n\n### Ví dụ:\n\n```plaintext\nunit radar closest enemy any target\nprint target\nprint flush\n```\n\n**Giải thích:** Kịch bản quét tìm đơn vị kẻ địch gần nhất và lưu kết quả vào biến `target`, sau đó in ra.\n\n## unit locate\n\nLệnh `unit locate` tìm lõi, điểm sinh đơn vị hoặc kẻ địch gần nhất.\n\n### Cú pháp:\n\n```plaintext\nunit locate [mục_tiêu] [tọa_độX] [tọa_độY] [biến_kết_quả]\n```\n\n### Ví dụ (Tìm lõi gần nhất):\n\n```plaintext\nunit locate core coreX coreY found\nprint coreX\nprint coreY\nprint found\nprint flush\n```\n\n**Giải thích:** Kịch bản tìm lõi gần nhất, lưu tọa độ của nó vào `coreX` và `coreY`. Biến `found` cho biết có tìm thấy lõi hay không.\n\n## Kết Luận\n\n- Dùng `unit bind` để gán một đơn vị để điều khiển.\n- Dùng `unit control` để ra lệnh cho đơn vị đã gán.\n- Dùng `unit radar` để quét tìm đơn vị xung quanh theo tiêu chí.\n- Dùng `unit locate` để tìm các vị trí chiến lược như lõi và kẻ địch.\n\nNắm vững các lệnh này sẽ giúp bạn tạo các kịch bản tự động hóa đơn vị hiệu quả trong Mindustry Logic.\n"
  }
]